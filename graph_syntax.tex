\section{Graph-based Problem Formulation Syntax}
	For a large scale problem with many analyses, obtaining the FPF is likely to be a challenge. In general, at set of analysis codes will be given and the desired outputs will be specified as
	    \begin{align}
            given & \ \ A: \lbrace x_i \lvert i \in A_\textrm{input} \rbrace \rightarrow \lbrace x_i \lvert i \in A_\textrm{output} \rbrace \notag
            \\    & \ \ B: \lbrace x_i \lvert i \in B_\textrm{input} \rbrace \rightarrow \lbrace x_i \lvert i \in B_\textrm{output} \rbrace \notag
			\\    & \ \ \quad \quad \quad \quad \quad \quad  \quad \quad \vdots
            \\min. &\ \ f(x_i), i \in \mathcal{O} \notag
            \\w.r.t. & \ \ x_i, i \in \mathcal{I}, \notag
            \label{eqn:preFPF}
        \end{align}
	where $\mathcal{O}$ is the index set of the global outputs and $\mathcal{I}$ is the index set of the global inputs. For this to be an FPF, there must be no \emph{conflicts} or \emph{holes}. A conflict arises when different analyses produce the same output; two analysis codes $A$ and $B$ are in conflict if
		\begin{equation}
			A_\textrm{output} \cap B_\textrm{output} \neq \emptyset.
		\end{equation}
	A hole arises when a local input to an analysis block is neither a global input nor a local output of any analysis block. If we let $\mathcal{H}$ denote the index set of local inputs which are holes
		\begin{equation}
			i \in \bigcup (A_\textrm{input},B_\textrm{input},\ldots) \textrm{ and } i \notin \bigcup (\mathcal{I},A_\textrm{output},B_\textrm{output},\ldots)  \implies  i \in \mathcal{H}.
		\end{equation}
	If the given set of analyses contains any holes, an FPF cannot be obtained. On the contrary, if there are conflicts multiple FPFs may be obtained. This is because every conflict represents a choice of which analysis to use and each choice could (potentially) yeild a different but valid FPF. The following section develops an application of graphy theory to obtain multiple FPFs from a set of analyses and desired outputs.
		
    \subsection{Formulation Graph Syntax}
    Rather than start with an adjacency, we chose to work directly with a directed cyclic graph to develop a syntax for the FPF. 
    The following information must be provided to start:
    \begin{itemize}
        \item Analysis blocks: an analysis block represents any calculation, and each comes with
            \begin{itemize}
                \item local inputs
                \item local outputs 
                \item execution properties: these are the properties associated with running the code, such as run time
            \end{itemize}
        \item Global parameters: these may serve as fixed inputs to the local inputs of analysis blocks
        \item Global outputs: these may represent
            \begin{itemize}
                \item objectives
                \item constraints
                \item residuals: (not sure)
            \end{itemize}
    \end{itemize}

    The graph representation of a data flow is cast to utilize the extensive library of algorithms in graph theory to analyze a directed weighted graph. 
    Edge weights are used to represent the metrics associated with a data flow:
    \begin{itemize}
        \item Run time: this metric is a property of an analysis block
        \item Fidelity: this metric is a property of an individual local output
        \item Expected Convergence
    \end{itemize}

    The key assumption is that identical variables are recognized as such. This serves as the basis for creating a data flow by connecting compatible input and output nodes with a directed edge. 
    To represent the fact that execution of an analysis code does not depend on the number of outputs being used, we have created the following figure (not made yet).
    
    This information immediately leads to the maximal connectivity graph, which is formed by placing a directed edge from each local output or global parameter to each matching local input or global output. 
    Whenever multiple edges are connected to a single input, a conflict occurs because only one may be used. Resolving these conflicts is one key challenge in creating a data flow.
%    \begin{itemize}
%        \item Specify analyses
%        \item Connections between analyses 
%            \begin{itemize}
%                \item local variables
%                \item global variables? Use "fake" node that broadcasts out to the rest of the graph? 
%            \end{itemize}
%        \item Cycles indicate coupling
%        \item Cycles for design variables->objectives/constraints
%        \item Objectives/constraints are just outputs? Special nodes? 
%        \item Residuals are just outputs? Special nodes? 
%        \item Parameters are just input nodes that are not design variables (use identifies these)
%        \item FPF no solvers/optimizers anywhere in it
%    \end{itemize}

    \subsection{Solution Graph Syntax}
    What is the difference between a problem formulation and a problem solution method? Convert from a cyclic graph, to an acyclic graph
    \begin{itemize}
        \item Cycles indicate convergence loops or design variable loops
        \item Problem can't be solved until all loops are *removed* by adding solvers/optimizers
        \item *Special* nodes for solvers and optimizers that *break* loops (from an algorithmic point of view)
        \item FPF represents the minimal amount of information necessary to define a problem
        \item Any solution path grows the graph complexity by adding edges and nodes (or possibly have an empty solution graph, which you build up
        as you remove edges from problem formulation graph?)
    \end{itemize}
